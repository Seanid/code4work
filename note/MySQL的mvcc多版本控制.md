## 什么是MVCC

---

MVCC（多版本并发控制），是一种并发控制的方法，一般在数据库中，用于对数据库数据的并发访问控制，在程序中用于实现内存事务的功能

## 作用是什么（解决什么问题）

---

MVCC主要解决的是一个数据并发访问的问题。在高并发访问的情况下，

为了保证数据读取的准确性，可以采用加锁或者版本控制的方法处理。
* 加锁，在进行写入或者更新操作的过程中，给数据加上一个锁，让所有读都进入等待状态，这种处理方式牺牲了效率，来达到数据的稳定性
* 版本控制，通过给数据加入版本号或者时间戳的方式，在某个时间内，读操作读取到的都是数据的一个快照，写操作在完成之前（事务提交之前）都是不可见的。由于有多个版本，所以每次读都能够读取到准确的快照数据，相互之间并不影响，由此来达到并发访问的效果。

Mysql 的MVCC 解决的问题主要包括：
* 高并发场景下的读-写，写-写的问题
  * 读-写：同数据的并发读写，存在线程安全问题，可能会造成数据的脏读、幻读、不可重复读
  * 写-写：同一数据的多次写，存在线程安全问题，可能存在着更新丢失的问题，即ABA问题
* 高并发场景下的性能问题：高并发下，如果采用锁的方式处理数据读写问题，会导致阻塞，MVCC属于是无锁并发处理，解决了高并发下的读写性能问题
* 实现了事务的隔离，MVCC提供的快照服务，实现了多个事务之间对同一条数据不同阶段查询的支持

基于MVCC，Mysql实现的高性能的查询（非加锁模式），实现了多个事务级别的隔离（read-view+多版本），数据的一致性读（read-view）等功能.

所谓的一致性非锁定读，就是指的MVCC机制

## Mysql中的MVCC如何实现的（怎么解决的）

---

- 隐藏字段
- undo日志
- read-view
- 快照读+当前读

### 隐藏字段

在Mysql的每行数据中，除了自定义的字段外，数据库会隐式定义三个字段，包括DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID，除此之外，还有一个删除状态的flag表。

- DB_TRX_ID
    - 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
- DB_ROLL_PTR
    - 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
- DB_ROW_ID
    - 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
- 删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了

![](http://image.e65535.com/github/20240618135339.png)

MVCC下的增删改查逻辑：

- 插入
    - 获取全局事务ID，1
    - 插入数据，insert into `test_zq` (`id`, `test_id`) values('5','68'); insert into `test_zq` (`id`, `test_id`) values('6','78');
    - 提交事务
    - 得到的结果：idtest_idDB_TRX_IDDB_ROLL_PT5681NULL6781NULL
- 删除
    - 获取全局事务ID，3
    - 删除数据，delete test_zq where id = 6;
    - 提交事务
    - 得到结果，idtest_idDB_TRX_IDDB_ROLL_PT5681NULL67813
- 修改
    - 获取全局事务ID，10
    - 更新数据，update test_zq set test_id = 22 where id = 5;
    - 复制当前记录，修改当前记录回滚指针为当前事务，新的记录，回滚指针为空，事务版本号为当前事务
    - 提交事务
    - 得到结果，idtest_idDB_TRX_IDDB_ROLL_PT5681106781352210NULL
- 查询
    - 查询数据行，版本号需要早于当前事务版本号
    - 查询删除行，删除版本号要么是null，要大于当前版本号，保证该数据在事务开始前不会被删除
    - 查询的结果，idtest_idDB_TRX_IDDB_ROLL_PT62210NULL

### undo log

undoLog 在Mysql中主要用于事务的回滚，同时也是MVVC的重要组成部分，因为undo log中保存了数据中的旧版本快照。当事务未提交的时候，读取一行被其他事务操作过的数据是，需要通过undo log

来进行分析出之前的快照数据。

undo log 保存在数据文件*idb中

MVCC的快照读，就是通过undo log 来实现不同事务版本号都拥有自己的快照版本

undo log 包括两种：

- insert undo log：插入新数据的时候产生，只有当事务需要回滚的时候才会用到，当事务被提交，即立刻丢弃
- update undo log：更新或者删除数据的时候产生，不仅用于数据回滚，在读取快照的时候，也会使用，不能随便删除，只有快速读取或者事务回滚不涉及时，才会通过purge线程统一删除

![](http://image.e65535.com/github/20240618135430.png)

### read-view（读视图）

read-view 是mysql 进行事务的快照读操作时产生的，在该事务的快照读产生的那一刻，会生产一个数据库当前的快照，记录维护当前活跃的事务ID

read-view的属性：

- trx_ids: 当前系统活跃(未提交)事务版本号集合。
- low_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”
- up_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”
- creator_trx_id: 创建当前read view的事务版本号；

read-view 主要用于可见性的判断，当事务进行快照读的时候，首先通过read-view 来判断当前事务能够看到哪个版本的数据，通过这个来确定从undo log 里面读取的数据的版本

![](http://image.e65535.com/github/20240618135517.png)

不同模式下，read-view的不同结果

- 在RR级别下，某个事务对某条数据的第一次查询，会产生一次快照和read-view，此后的读，使用的都是该快照，所以在后期就会使用同一个read-view，读取到的结果是一致的
- 在RC级别下，事务每次读取，都会生产一次全新的快照和read-view ，所以RC下可以查询到其他事务提交的东西

### 当前读与快照读

当前读，指读取当前记录最新的版本，通常需要通过加锁的方式来保证数据读取的时候不被修改。

快照读，基于MVVC读取到的多版本的数据，可以避免加锁，但是，通常需要在非串行级别下读取。

