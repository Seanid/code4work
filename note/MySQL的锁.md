## 关于锁
锁，是数据库系统区别与文件系统的一个关键性特征，主要用于高并发下，资源的访问，目的是保证数据的完整性和一致性。

在程序中，锁的对象，通常是一些临界的资源，在Mysql中，锁的控制对象是事务，用来锁定的是数据库的对象，如表、页、行等。通常锁会在事务提交或者回滚后进行释放。


## MySQL 锁的分类

### 粒度分类
* 表锁（myisam）：基于表级别的锁，加锁快，开销小，冲突的概率低，并发低
* 页锁（BDB）：性能基于表锁与行锁，锁的主要是MySQL的数据页
* 锁（Innodb）：基于数据行的索引字段的加锁，加锁慢，开销大，冲突多，并发高，Innodb使用的就是基于索引的行锁

### 锁的级别分类
* 共享锁（S）：又称读锁，允许其他事务读，不允许写（SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE）
* 排他锁（X）：又称写锁，既不允许其他事务读，也不允许写（SELECT * FROM table_name WHERE ... FOR UPDATE）

除了标准的排他锁和共享锁之外，innodb 还支持了多粒度的锁定，即在行锁的基础上，还支持表锁和页锁。
其中，意向锁就是一种多层级别的加锁。意向锁是mysql自发产生的表级锁，用户不必自动触发

意向锁存在的作用，是锁获取检测阶段，因为当一个事务要获得数据的行级别锁的时候，就需要获取到表级别的意向锁，这样就不需要进行细粒度锁的排查，减少了不必要的消耗

* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。 
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

### 特殊类锁
* 自增锁

自增锁，是mysql 针对自增长索引的一种特殊的表级别锁，主要通过auto_increment来指定，可以用在主键字段上，也可以用在非主键字段上，但是需要有索引，且必须是索引的第一列，这样才能通过类似的select max（）的语句来定位到最大的值。同时，由于其特殊性，它不需要等待事务的提交，就能释放锁。

自增锁是属于表锁，不同的版本有不同的实现

* mysql 5.1之前，auto_increment 采用的是严格递增的方式，mysql 会针对每条插入语句加一个全表维度的锁，该锁保证每次只能有一条插入语句执行，每次插入，都会产生一个自增数据。但同时，也导致并发非常差
* mysql 5.1之后，不再进行全表的auto-inc锁，而是通过一个轻量的互斥锁来进行控制，等自增数据分配好，锁就会被释放。
* 虽然5.1之后，采用了轻量锁模式，但是在批量插入的时候，还是会导致全表的auto-inc模式，如INSERT ... SELECT。主要由于，基于执行语句的主从复制模式，所有语句不能和执行顺序相关，该模式在8.0后的基于数据行的复制得到了实现
* 自增锁的模式，可以通过innodb_autoinc_lock_mode来进行配置
* 不推荐显式指定自增列数据，因为在5.7以及之前的版本，如果通过update语句显式指定一个比SELECT MAX(*ai_col*)还大的自增列值，后续insert语句可能会抛"Duplicate entry"错误，这一点在8.0版本之后也有了改变，如果通过显式的update语句显式指定一个比SELECT MAX(*ai_col*)还大的自增列值，那该值就会被持久化，后续的自增列值都从该值开始生成

### 锁的对象分类

Innodb 中，按锁的对象实现，主要有3种：

* 记录锁：锁定一条记录，当查询有唯一性索引的时候（Primary key ，Unique key）产生
* 间隙锁：锁定一定范围内的记录，但不包含记录本身，主要是当查询锁定的是范围记录时（只有在RR模式下起作用）
* 临键锁：间隙锁+记录锁，innodb 默认采用的算法，主要是结合了记录所和间隙锁的优势，采用的是范围查询，左开右闭。

锁的降级：在innodb中，默认采用的是临键锁，当进行等值查询或范围查询，且记录不存在的时候，临键锁会退化为间隙锁，当采用的是唯一查询的时候，退化为记录锁

临键锁+间隙锁存在的意义？为什么不直接都是用记录就行了？

临键锁的意义在于解决了一个幻读的作用，当只对已有记录进行加锁的时候，这就意味，在范围中间插入数据不受影响，这就可能会导致，同一事务下，两次范围查询查询到的数据不同，因此导致了幻读。


MySQL 的 Innodb引擎正是通过上述不同类型的锁，完成了事务隔离：

* 加 X 锁 避免了数据的脏读
* 加 S 锁 避免了数据的不可重复读
* 加上 Next Key 避免了数据的幻读